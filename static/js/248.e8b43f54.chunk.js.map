{"version":3,"file":"static/js/248.e8b43f54.chunk.js","mappings":"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","sources":["services/halalService.ts"],"sourcesContent":["import { Merchant } from '../data/merchants';\n\ninterface HalalEstablishment {\n  name: string;\n  address: string;\n  type: string;\n  number: string;\n  scheme: string;\n  id: string;\n  postal: string;\n}\n\nexport class HalalService {\n  private static halalEstablishments: HalalEstablishment[] = [];\n  private static initialized = false;\n\n  static async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    const maxRetries = 3;\n    let lastError: Error | null = null;\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        console.log(`Attempt ${attempt}/${maxRetries}: Fetching halal establishments...`);\n\n        // Add timeout and retry logic\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout\n\n        const response = await fetch(\n          'https://raw.githubusercontent.com/zootato/singapore-halal-establishments/main/halal_establishments.json',\n          {\n            signal: controller.signal,\n            headers: {\n              'Cache-Control': 'no-cache',\n              'Pragma': 'no-cache'\n            }\n          }\n        );\n\n        clearTimeout(timeoutId);\n\n        if (!response.ok) {\n          throw new Error(`GitHub API returned ${response.status}: ${response.statusText}`);\n        }\n\n        this.halalEstablishments = await response.json();\n        this.initialized = true;\n        console.log(`‚úÖ Successfully loaded ${this.halalEstablishments.length} halal establishments from GitHub`);\n        return;\n\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        console.warn(`‚ùå Attempt ${attempt} failed:`, lastError.message);\n\n        // Wait before retry (exponential backoff)\n        if (attempt < maxRetries) {\n          const delay = Math.pow(2, attempt) * 1000; // 2s, 4s, 8s\n          console.log(`‚è≥ Retrying in ${delay/1000}s...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    // All retries failed\n    console.error(`üö´ Failed to load halal establishments after ${maxRetries} attempts:`, lastError?.message);\n    console.error('üîÑ Halal filtering will be disabled for this session');\n    this.halalEstablishments = [];\n    this.initialized = true;\n  }\n\n  static async isHalal(merchant: Merchant): Promise<{ isHalal: boolean; source: string; certNumber?: string }> {\n    await this.initialize();\n\n    // If halal data failed to load, return unknown status\n    if (this.halalEstablishments.length === 0) {\n      console.log(`‚ö†Ô∏è No halal data available - cannot verify \"${merchant.name}\"`);\n      return {\n        isHalal: false,\n        source: 'HALAL_DATA_UNAVAILABLE'\n      };\n    }\n\n    // Primary matching: Find the best name match\n    const bestMatch = this.findBestNameMatch(merchant.name, merchant.postalCode);\n\n    if (bestMatch) {\n      return {\n        isHalal: true,\n        source: bestMatch.source,\n        certNumber: bestMatch.establishment.number\n      };\n    }\n\n    // Only return halal if found in official records\n    return {\n      isHalal: false,\n      source: 'NOT_IN_OFFICIAL_RECORDS'\n    };\n  }\n\n  private static findBestNameMatch(merchantName: string, merchantPostal: string): { establishment: HalalEstablishment; source: string } | null {\n    const cleanMerchantName = this.cleanName(merchantName);\n\n    // 1. Perfect match: Exact name + postal confirmation\n    const exactNameMatch = this.halalEstablishments.find(halal =>\n      this.cleanName(halal.name) === cleanMerchantName\n    );\n\n    if (exactNameMatch) {\n      if (exactNameMatch.postal === merchantPostal) {\n        return { establishment: exactNameMatch, source: 'MUIS_VERIFIED_EXACT_POSTAL' };\n      }\n      return { establishment: exactNameMatch, source: 'MUIS_VERIFIED_EXACT_NAME' };\n    }\n\n    // 2. High similarity match with postal confirmation\n    const merchantWords = cleanMerchantName.split(' ').filter(word => word.length > 2);\n    let bestMatch: { establishment: HalalEstablishment; similarity: number; hasPostal: boolean } | null = null;\n\n    for (const halal of this.halalEstablishments) {\n      const halalWords = this.cleanName(halal.name).split(' ').filter(word => word.length > 2);\n\n      // Calculate similarity score\n      const matchingWords = merchantWords.filter(word =>\n        halalWords.some(halalWord =>\n          halalWord.includes(word) || word.includes(halalWord) || this.isWordSimilar(word, halalWord)\n        )\n      );\n\n      const similarity = matchingWords.length / Math.max(merchantWords.length, halalWords.length);\n      const hasPostalMatch = halal.postal === merchantPostal;\n\n      // EXTREMELY STRICT: Require exact business name match + postal code OR very specific keywords\n      const hasSpecificMatch = this.hasSpecificBusinessMatch(merchantWords, halalWords, matchingWords);\n\n      if (similarity >= 0.95 && matchingWords.length >= 3 && hasSpecificMatch) {\n        console.log(`üïå POTENTIAL HALAL MATCH:\n          CDC: \"${merchantName}\" (postal: ${merchantPostal})\n          MUIS: \"${halal.name}\" (postal: ${halal.postal})\n          Similarity: ${(similarity * 100).toFixed(1)}%\n          Matching words: [${matchingWords.join(', ')}]\n          Postal match: ${hasPostalMatch ? '‚úÖ' : '‚ùå'}`);\n\n        if (!bestMatch ||\n            (hasPostalMatch && !bestMatch.hasPostal) || // Strongly prefer postal matches\n            (hasPostalMatch === bestMatch.hasPostal && similarity > bestMatch.similarity)) {\n          bestMatch = { establishment: halal, similarity, hasPostal: hasPostalMatch };\n        }\n      } else if (similarity >= 0.8 && matchingWords.length >= 2) {\n        // Log why this was rejected\n        const specificMatches = matchingWords.filter(word =>\n          !['western', 'food', 'kitchen', 'restaurant', 'cafe', 'stall', 'house', 'corner',\n            'snack', 'delight', 'express', 'garden', 'center', 'place', 'shop', 'store',\n            'pte', 'ltd', 'private', 'limited', 'trading', 'enterprise', 'company'].includes(word.toLowerCase())\n        );\n\n        console.log(`‚ùå REJECTED MATCH: \"${merchantName}\" vs \"${halal.name}\"\n          Reason: Similarity ${(similarity * 100).toFixed(1)}% (need 95%+), ${matchingWords.length} matches (need 3+), ${specificMatches.length} specific matches (need 2+)\n          Matching words: [${matchingWords.join(', ')}]\n          Specific matches: [${specificMatches.join(', ')}]`);\n      }\n    }\n\n    if (bestMatch) {\n      const result = bestMatch.hasPostal\n        ? { establishment: bestMatch.establishment, source: 'MUIS_VERIFIED_SIMILAR_POSTAL' }\n        : { establishment: bestMatch.establishment, source: 'MUIS_VERIFIED_SIMILAR_NAME' };\n\n      console.log(`‚úÖ HALAL CONFIRMED: \"${merchantName}\" ‚Üí \"${bestMatch.establishment.name}\" (Cert: ${bestMatch.establishment.number})`);\n      return result;\n    }\n\n    console.log(`‚ùå NOT HALAL: \"${merchantName}\" - no match found in MUIS database`);\n    return null;\n  }\n\n  private static hasSpecificBusinessMatch(merchantWords: string[], halalWords: string[], matchingWords: string[]): boolean {\n    // Generic words that shouldn't be the primary basis for matching\n    const genericWords = new Set([\n      'western', 'food', 'kitchen', 'restaurant', 'cafe', 'stall', 'house', 'corner',\n      'snack', 'delight', 'express', 'garden', 'center', 'place', 'shop', 'store',\n      'pte', 'ltd', 'private', 'limited', 'trading', 'enterprise', 'company'\n    ]);\n\n    // Check if there's at least one specific (non-generic) word match\n    const specificMatches = matchingWords.filter(word => !genericWords.has(word.toLowerCase()));\n\n    // Must have at least 2 specific word matches OR exact postal code match\n    return specificMatches.length >= 2;\n  }\n\n  private static isWordSimilar(word1: string, word2: string): boolean {\n    // Check for common abbreviations and variations\n    const commonVariations: { [key: string]: string[] } = {\n      'restaurant': ['rest', 'resto'],\n      'kitchen': ['kitchn', 'kitch'],\n      'food': ['fd'],\n      'house': ['hse'],\n      'corner': ['cnr'],\n      'centre': ['center', 'ctr'],\n      'international': ['intl'],\n      'company': ['co'],\n      'private': ['pte', 'pvt'],\n      'limited': ['ltd']\n    };\n\n    for (const [full, abbrevs] of Object.entries(commonVariations)) {\n      if ((word1 === full && abbrevs.includes(word2)) ||\n          (word2 === full && abbrevs.includes(word1)) ||\n          (abbrevs.includes(word1) && abbrevs.includes(word2))) {\n        return true;\n      }\n    }\n\n    // Check for simple character similarity (at least 80% similar)\n    const longer = word1.length > word2.length ? word1 : word2;\n    const shorter = word1.length > word2.length ? word2 : word1;\n\n    if (longer.length === 0) return false;\n\n    const editDistance = this.levenshteinDistance(longer, shorter);\n    const similarity = (longer.length - editDistance) / longer.length;\n\n    return similarity >= 0.8;\n  }\n\n  private static levenshteinDistance(str1: string, str2: string): number {\n    const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));\n\n    for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;\n    for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;\n\n    for (let j = 1; j <= str2.length; j++) {\n      for (let i = 1; i <= str1.length; i++) {\n        const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;\n        matrix[j][i] = Math.min(\n          matrix[j][i - 1] + 1,\n          matrix[j - 1][i] + 1,\n          matrix[j - 1][i - 1] + indicator\n        );\n      }\n    }\n\n    return matrix[str2.length][str1.length];\n  }\n\n  private static cleanName(name: string): string {\n    return name\n      .toLowerCase()\n      .replace(/\\b(pte|ltd|private|limited|sdn|bhd)\\b/g, '')\n      .replace(/\\b(stall|#|unit|\\d+[a-z]?)\\s*\\d+/g, '')\n      .replace(/[^\\w\\s]/g, ' ')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  }\n\n\n}"],"names":["HalalService","initialize","_lastError","this","initialized","lastError","attempt","console","log","concat","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","signal","headers","clearTimeout","ok","Error","status","statusText","halalEstablishments","json","length","error","String","warn","message","delay","Math","pow","Promise","resolve","isHalal","merchant","name","source","bestMatch","findBestNameMatch","postalCode","certNumber","establishment","number","merchantName","merchantPostal","cleanMerchantName","cleanName","exactNameMatch","find","halal","postal","merchantWords","split","filter","word","halalWords","matchingWords","some","halalWord","includes","isWordSimilar","similarity","max","hasPostalMatch","hasSpecificMatch","hasSpecificBusinessMatch","toFixed","join","hasPostal","specificMatches","toLowerCase","result","genericWords","Set","has","word1","word2","commonVariations","full","abbrevs","Object","entries","longer","shorter","editDistance","levenshteinDistance","str1","str2","matrix","Array","fill","map","i","j","indicator","min","replace","trim"],"sourceRoot":""}